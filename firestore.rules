rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function getUserId() {
      return isSignedIn() ? request.auth.uid : null;
    }

    function getUserRole() {
      return get(/databases/$(database)/documents/users/$(getUserId())).data.role;
    }

    function isSuperAdmin() {
      return isSignedIn() && getUserRole() == 'super_admin';
    }

    function isAdmin() {
      return isSignedIn() && getUserRole() == 'admin';
    }

    function isAdminOrSuperAdmin() {
      return isAdmin() || isSuperAdmin();
    }

    // --- Users ---
    match /users/{userId} {
      allow read: if isSignedIn() && (userId == getUserId() || isAdminOrSuperAdmin());
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;

      allow update: if isSignedIn() && (
        isAdminOrSuperAdmin() ||
        (
          userId == getUserId() &&
          request.resource.data
            .diff(resource.data)
            .changedKeys()
            .hasOnly([
              'firstName',
              'lastName',
              'company',
              'companyDomain',
              'domain',
              'loginAlerts',
              'passwordUpdatedAt'
            ])
        )
      );

      allow delete: if isSuperAdmin();
    }

    // --- Payments ---
    match /payments/{paymentId} {
      allow create: if isSignedIn()
        && request.resource.data.userId == getUserId()
        && request.resource.data.amount is number
        && request.resource.data.plan is string
        && request.resource.data.createdAt is timestamp;

      allow read: if isSignedIn() &&
        (resource.data.userId == getUserId() || isAdminOrSuperAdmin());

      allow update, delete: if false;
    }

    // --- Approval documents ---
    match /approval_documents/{docId} {
      allow create: if isSignedIn();
      allow read, update, delete: if isAdminOrSuperAdmin();
    }

    // --- Audit logs ---
    match /audit_logs/{logId} {
      allow create: if isSignedIn();
      allow read: if isSignedIn() &&
        (resource.data.userId == getUserId() || isAdminOrSuperAdmin());
      allow update, delete: if false;
    }

    // --- Alerts ---
    match /alerts/{alertId} {
      allow create: if isSignedIn();
      allow read: if isSignedIn() && (
        resource.data.userId == getUserId() ||
        resource.data.userId == 'all' ||
        isAdminOrSuperAdmin()
      );
      allow update, delete: if isAdminOrSuperAdmin();
    }

    // --- Policies ---
    match /policies/{policyId} {
      allow read: if true;
      allow create, update, delete: if isAdminOrSuperAdmin();
    }

    // --- Shared data ---
    match /shared_data/{docId} {
      allow create: if isSignedIn();

          // Read: allow owners and admins, and allow access when the document
          // is explicitly shared with the signed-in user. This supports either
          // an array of user ids (`sharedWith: ['uid', ...]`) or an array of
          // objects like `{ userId: '...' }` (attempt a best-effort check).
          allow read: if isSignedIn() && (
            resource.data.ownerId == getUserId() ||
            isAdminOrSuperAdmin() ||
            (
              resource.data.sharedWith is list && (
                // common case: sharedWith is an array of uids
                request.auth.uid in resource.data.sharedWith
                // fallback attempt: if sharedWith is an array of objects, try
                // to check the first element's userId as a heuristic. This is
                // a best-effort check â€” for robust querying prefer adding a
                // `sharedWithUserIds` array to documents or query from the
                // client with an explicit filter.
                || (resource.data.sharedWith.size() > 0 && resource.data.sharedWith[0].userId == request.auth.uid)
              )
            )
          );

      allow update: if isSignedIn() &&
        (resource.data.ownerId == getUserId() || isAdminOrSuperAdmin());

      allow delete: if isSuperAdmin();
    }

    // --- User login counters ---
    match /user_logins/{userId} {
      allow create, update: if isSignedIn() &&
        (userId == getUserId() || isAdminOrSuperAdmin());

      allow read: if isSignedIn() &&
        (userId == getUserId() || isAdminOrSuperAdmin());

      allow delete: if isSuperAdmin();
    }


// --- Messages / Chat ---
match /messages/{messageId} {
  // Create: sender must be the authenticated user, participants must be exactly two distinct uids,
  // convoId present, and timestamp present.
  allow create: if isSignedIn()
    && request.auth.uid == request.resource.data.from
    && request.resource.data.participants is list
    && request.resource.data.participants.size() == 2
    && request.resource.data.participants.hasAll([request.resource.data.from, request.resource.data.to])
    && request.resource.data.from != request.resource.data.to
    && request.resource.data.convoId is string
    && request.resource.data.timestamp is timestamp;

  // Read: only participants (or admins) can read. Also allow queries that
  // include an `array-contains` filter on `participants` for realtime
  // subscriptions (the client uses `where('participants','array-contains', uid)`).
  allow get, list: if isSignedIn() && (
    request.auth.uid in resource.data.participants ||
    isAdminOrSuperAdmin() ||
    // allow list queries that filter by participants containing the caller
    // (this makes the common `array-contains` subscription work)
    (request.query != null && request.query.where('participants', 'array-contains', request.auth.uid))
  );

  // Update: allow admins OR participants to change only small mutable fields.
  // - Any participant may toggle `starred`.
  // - Only the message recipient may set `read` to true.
  allow update: if isSignedIn() && (
    isAdminOrSuperAdmin() ||
    (
      request.auth.uid in resource.data.participants
      && request.resource.data.participants == resource.data.participants
      && request.resource.data.from == resource.data.from
      && request.resource.data.to == resource.data.to
      && (
        // toggle starred
        (request.resource.data.diff(resource.data).changedKeys().hasOnly(['starred']))
        ||
        // mark read: only recipient may mark their incoming message read
        (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['read'])
          && request.resource.data.read == true
          && resource.data.to == request.auth.uid
        )
      )
    )
  );

  // Delete: only super_admin or original sender
  allow delete: if isSuperAdmin() || (isSignedIn() && resource.data.from == getUserId());
}


    // --- Usernames ---
    match /usernames/{username} {
      allow get, list: if true;
      allow create: if request.auth != null &&
        request.resource.data.uid == request.auth.uid;
      allow update, delete: if isSuperAdmin();
    }

    // --- Fallback deny ---
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
